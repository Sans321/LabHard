//----------------------------------------------------------------------------------------------------------------------------------------------
//Разработчик проекта: Свита Артем Николаевич - группа 1191б
//
//Цель: разработать программу для вывода чисел в двенадцетиричной системе счисления на семисегментном индикаторе
//
//Решаемые проектом задачи:
//	1. На основе константных и варьируемых бит  определять значение числа в десятичной системе счисления
//	2. Преобразовывать число из десятичной системы счисления в систему с основанием четыре
//	3. Кодировать каждую цифру числа символом для семисегментного индикатора
//	4. Выводить все цифры числа на семисегментном индикаторе, начиная со старшей цифры.
//----------------------------------------------------------------------------------------------------------------------------------------------

#include "main.h"	//Заголовчоный файл с описанием подключаемых библиотечных модулей

//main обязательная функция для исполнегия кода пользователя
//После подачи питания или щелчка кнопкой "reset" стартует Загрузкчик, который выполняет начальную настройку основых регистров микроконтроллера 
//В завершение работы Загрузчик передаёт управление микроконтроллером функции main
int main(void)
{
	//Конфигурирование портов GPIO 
	RCC->AHBENR |= RCC_AHBENR_GPIOBEN; 																							 		//Включение тактирования порта B: RCC_AHBENR_GPIOBEN=0x00040000			
	GPIOB->OSPEEDR |= 0x00005555;																												//установка частоты переключения выводов PB.0 – PB.7 на уровне 10 МГц
	GPIOB->MODER |= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER1_0 | GPIO_MODER_MODER2_0 |		//Переключение линий 0-7 и 9 порта B в режим "Output"
									GPIO_MODER_MODER3_0 | GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0 |
									GPIO_MODER_MODER6_0 | GPIO_MODER_MODER7_0 | GPIO_MODER_MODER9_0;
	GPIOB->MODER&=~( GPIO_MODER_MODER12 | GPIO_MODER_MODER13 |  												//Переключаем линий 12(SW4),13(SW3),14(SW2),15(SW1)порта B в режим "Input"
									 GPIO_MODER_MODER14 | GPIO_MODER_MODER15);													
	
	uint16_t input[8] = {0, 0, 0, 0, 0, 0, 0, 1} ;																			//Входное занчение числа (в двоичной системе)
	uint16_t n = 0;																																			//Значение числа в десятичной системе
	uint16_t output[12] = {0,0,0,0,0,0,0,0,0,0,0,0};																											//Массив с числом в двенадцатиричной системе (в обратном порядке)
	unsigned reg[12] = {0x0000023F, 0x00000206, 0x0000025B, 0x0000024F,0x00000266,0x0000026D,0x0000027D,0x00000207,0x0000027F,0x0000026F,0x00000277,0x0000027C};									//Регистры семисегментного индикатора, цифры 0,1,2,3,4,5,6,7,8,9,10,11 соответственно
	//Реализация вывода на семисегментный индикатор
	while(1){
		n=0;
		input[1]=((GPIOB->IDR)&0x8000)>>15;																								//Считывание значения переключателя SW1
		input[4]=((GPIOB->IDR)&0x4000)>>14;																								//Считывание значения переключателя SW2
		input[6]=((GPIOB->IDR)&0x2000)>>13;																								//Считывание значения переключателя SW3
		input[7]=((GPIOB->IDR)&0x1000)>>12;																								//Считывание значения переключателя SW4
		uint32_t j=7;																																			//Разряд двоичного числа
		//Перевод числа в десятичную систему
		for (uint16_t i = 0 ; i<8; i++){         
			n += input[i]* powi (2, j);																											//расчёт числа в десятичной системе
			j--;																																						//переход к следующему разряду
		}
		//Перевод числа в 12 систему
		for (uint16_t i = 0 ; i<12; i++){       
			if(n<12) {																																				//условие срабатывает, если десятичное число меньше разрядности
				output[i] = n;																																//в выходной массив записывается значение числа
				break;																																				//цикл прерывается
			}
			output[i] = n%12;																																//в выходной массив записывается остаток от деления на 12 
			n = n/12;																																				//в число n записывается целая часть от деления
		} 
		//вывод числа на семисегментном индикаторе
		for (int16_t i =3; i>=0; i--){
			if(i == 3 & output[i]== 0){																											//отбрасываем 0 в старшей цифре числа (если он есть)
				continue;}
			GPIOB->BSRR|=reg[output[i]];																										//ввыод цифры числа
				delay(200000);																																//задержка в 2 секунды
				GPIOB->BSRR|=0xffff0000;																											//выключение индикатора
			delay(50000);																																		//задержка в 0,5 секунды
		}
		GPIOB->BSRR|=0x00000280;																													//вывод точки
		delay(500000);																																		//задержка в 5 секунд 
		GPIOB->BSRR|=0xffff0000;																													//выключение индикатора
	}
}

//powi функция для вычисления степени числа
//x - число кторое нужно возвести в степень, n - степень в которую нужно возвести
//возвращает число возведённое в степень
uint32_t powi(uint32_t x, uint32_t n)
{
    if (n==0)																																					//если степень равна 0
        return 1;																																				//возвращается единица
    else if (n==1)																																		//если степень равна 
			return x;																																					//возвращается искомое число
    else if (n % 2 == 0 )																															//если степень чётная
			return powi( x * x, n/2);																													//производится рекурсия, передаётся число умноженное на себя и половина степени
    else																																							//если степень нечётная
        return powi( x * x, n /2)*x;																										//производится рекурсия, передаётся число умноженное на себя и половина степени
}																																											//результат умножнается на искомое число

//функция задержки: count - количество элементарных периодов задержки с длительностью примерно 2,5 мкс
void delay(uint32_t count)
{
	volatile uint32_t i;																																//объявляем неоптимизируемую переменную
	for (i =0;i<count;i++);																															//выполнение пустых циклов для реализации програмной задержки
}
//----------------------------------------------------------------------------------------------------------------------------------------------
//Руководство пользователя:
//	1. Для запуска загруженной программы удалите перемычку "boot" на стенде и нажмите "reset" 
//  2. Число задаётся с помощью переключателей SW1, SW2, SW3, SW4
//	3. Задаваемое число имеет вид: 0 (SW1) 1 1 (SW2) 0 (SW3) (SW4)
//	4. На семисегментном индикаторе, начиная со старшей цифры, выводится число, в окончании выводится точка
//----------------------------------------------------------------------------------------------------------------------------------------------

