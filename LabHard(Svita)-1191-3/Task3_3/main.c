/*----------------------------------------------------------------------------------------------------------------------------------------
**Проект: "Interrupt-NVIC".
**Назначение программы: псевдопараллельное выполнение двух задач:
**																									* мигание светодиодом с аппаратным контролем частоты переключения;
**																									* определение ASCII-кодов клавиш, нажимаемых на удаленном терминале;
**Разработчик: Свита Артем Николаевич - 1191б
**Цель: создание программы, использующей внутренние прерывания микроконтроллера STM32F072RBT 
**Решаемые задачи:
**		1. Реализация функции-обработчика внутреннего прерывания микроконтроллера STM32F072RBT (USART);
**		2. Конфигурирование NVIC;
**		3. Настройка модуля USART на генерацию сигнала прерывания при возникновении заданных событий.
**----------------------------------------------------------------------------------------------------------------------------------------*/

#include "main.h"

static uint8_t buf[256];							 //Буфер данных, передаваемых на ПК посредством USART
static uint32_t iReadyTX, iCompleteTX; //Количество битовых пакетов готовых для передачи и переденных на ПК соответственно int main ()
static uint32_t sum = 4, d = 2, n = 1, curA = 4;
static uint8_t flag;
static uint8_t flagF = 0;

int main()
{
	__disable_irq();					//Глобальное запрещение прерываний
	iReadyTX = 0;																							//Сброс количества битовых пакетов, подготовленных для передачи на ПК
	iCompleteTX = 0;																					//Сброс количества битовых пакетов, переданных на ПК через USART
	InitUSART1();																							//Инициализация модуля USART1
	NVIC->ISER[0] |= 0x08000000; 															//Разрешение в NVIC прерывания от модуля USART1 	
	__enable_irq();																						//Глобальное разрешение прерываний 

	while(1){
		if(n == 16){
			sum = 4;
			d = 2;
			n = 1;
			curA = 4;
		}
		debug();
		curA = curA + d;
		sum += curA;
		n += 1;	
	}
}

//Функция инициализации USART лабораторного комплекса
void InitUSART1(){
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;													//Включение тактирования USART1
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;														//Включение тактирования порта А
	
	//Настройка линий порта А: РА9(ТХ_1) - выход передатчика; PA10(RX_1) - вход приёмника
	GPIOA->MODER |= 0x00280000;																		//Перевести линии РА9 и РА10 в режим альтернативной функции
	GPIOA->AFR[1] |= 0x00000110;																	//Включить на линиях РА9 и РА10 альтернативную функцию AF1
	
	//Настройка линии передатчика Тх (РА9)
	GPIOA->OTYPER &= ~GPIO_OTYPER_OT_9;														//Сбросить 9 бит GPIOA->OTYPER - переключение в режим push-pull для линии РА9 (активный выход) 
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR9;														//Отключение подтягивающих резисторов для линии РА9 
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEEDR9;											//Установка высокой скорости синхронизации линии РА9
	
	//Настройка линии приемника Rx (РА10)
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR10;													//Сброс режима подтягивающих резисторов для линии РА10
	GPIOA->PUPDR |= GPIO_PUPDR_PUPDR10_0;													//Включение подтягивающего резистора pull-up на входной линии РА10 (вход приемника Rx)
	
	//Конфигурирование USART
	USART1->CR1 &= ~USART_CR1_UE;																	//Запрещение работы модуля USART1 для изменения параметров его конфигурации
	USART1->BRR=69;																								/*Настройка делителя частоты, тактирующего USART и задающего скорость приема и передачи данных на уровне 115200 бит/с: 
																																	Частота тактирующего генератора = 8 МГц 
																																	Скорость обмена по USART - 115200 бит/с; коэффициент деления - 8000000 / 115200 - 69,4444(4); Округленное значение - 69*/
	USART1->CR1 = USART_CR1_TE | USART_CR1_RE;										/*Разрешить работу приемника и передатчика USART. Остальные биты этого регистра сброшены, что обеспечивает: 
																																	количество бит данных в пакете 8;
																																	контроль четности - отключен; 
																																	прерывания по любым флагам USART - запрещены;
																																	состояние USART - отключен*/
	USART1->CR1 |= USART_CR1_RXNEIE | USART_CR1_TCIE; 						/*Разрешение (в модуле USART1) на выдачу сигнала прерывания при возникновении событий:
																																	прием кадра в буферный регистр; завершение передачи кадра */
	USART1->CR2 = 0;																							//Количество стоповых бит - 1
	USART1->CR3 = 0;																							//DMA1 - отключен
	USART1->CR1 |= USART_CR1_UE;																	//По завершении конфигурирования USART разрешить его работу (биту UE регистра CR1 присвоить 1)
}

//Функция-обработчик прерывания от модуля USART1 
void USART1_IRQHandler(void)
{	
	uint16_t pack;
	//Событие готовности принятых данных к чтению 
	if (USART1->ISR & USART_ISR_RXNE) { 												//Если в регистре состояний USART1 установлен флаг "RXNE", то
		pack=USART1->RDR; 																//Чтение принятого битового пакета из буферного регистра приемника USART1 
		switch ( pack ) {
		case 0x69:
			flag = 2;
			flagF = 0;
			break;
		case 0x65:
			flag = 3;
		  flagF = 0;
			break;
		case 0x73:
			flag = 4;
		  flagF = 0;
			break;
		// Начало обработки нажатия на F5
		case 27:
			flagF = 1;
			break;
		case 91:
			if (flagF == 1){
				flagF = 2;
			}
			break;
		case 49:
			if (flagF == 2){
				flagF = 3;
			}
			break;
		case 53:
			if (flagF == 3){
				flagF = 4;
			}
			break;
		case 126:
			if (flagF == 4){
				flagF = 0;
				flag = 1;
			}
			break;
		case 0x71:
			flag = 1;
			break;
		default:
			flagF = 0;
			break;
		}	
		// Конец обработки нажатия на F5
	}
	
	//Событие завершение передачи битового пакета 
	if (USART1->ISR & USART_ISR_TC) {														//Если в регистре состояний USART1 установлен флаг "ТС", то
		// Сброс флага завершения передачи кадра 
		USART1->ICR=USART_ICR_TCCF;																//Сбросить флаг завершения передачи кадра, чтобы прерывание не сработало повторно
		//Если количество переданных данных меньше, чем количество подготовленных для передачи, то передать следующий битовой пакет из программного буфера в USART1 для отправки на ПК
		if (iCompleteTX<iReadyTX){
			USART1->TDR = buf[(uint8_t)iCompleteTX++];
		}
	}	
}

void debug(){
	while(1){
		if(flag == 1){
			flag = 0;
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0D;		
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0A;			
			break;
		}
		if(flag == 2){
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x6E;				
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x3D;				
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			output(n);	
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0D;		
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0A;			
			flag = 0;				
		}
		if(flag == 3){
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x41;				
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x6E;		
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x3D;						
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			output(curA);	
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0D;		
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0A;					
			flag = 0;				
		}
		if(flag == 4){
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x73;				
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x3D;				
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			output(sum);	
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0D;		
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
			USART1->TDR = 0x0A;	
			flag = 0;
		}
	}
}

void output (uint32_t number){
	uint8_t notZero = 0;
	uint8_t d100;
	d100=(uint8_t)(number/100);
	if (d100 != 0){
		notZero = 1;
		number -= d100*100;	
		while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
		USART1->TDR = d100 + 48;
	}
	if (notZero == 1 ||  number/10 != 0){
		while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
		USART1->TDR = (uint8_t)(number/10 + 48);
	}
	while ((USART1->ISR & USART_ISR_TXE) == 0) {} 							//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
	USART1->TDR = (uint8_t)(number%10 + 48);
	notZero = 0;
}


/*----------------------------------------------------------------------------------------------------------------------------------------
**Руководство пользователя:
**		1. Запустите программу на лабораторном комплексе ЗТМ_01;
**		2. В управлении частотой мигания светодиода используйте микропереключатели SW3(старший разряд) и SW4(младший разряд). Примерная частота мигания: 00-4 Гц; 01-2 Гц; 10-1 Гц; 11 - 0.5 Гц;
**		3. На компьютере запустите приложение PuTTY и подключитесь к соответствующему COM-порту на скорости 115200 бит/с;
** 		4. При активном окне терминала нажмите различные кнопки клавиатуры и отследите ASCII-код каждой клавиши (управляющим клавишам должны соответствовать последовательности ASCII-кодов);
**----------------------------------------------------------------------------------------------------------------------------------------*/
